<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>blocknet nodemap</title>

    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16.png">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        :root {
            --bg: #000;
            --panel: rgba(0, 0, 0, 0.85);
            --panel-solid: #050505;
            --border: rgba(255, 255, 255, 0.12);
            --border-strong: rgba(255, 255, 255, 0.18);
            --text: #e6e6e6;
            --muted: #7d7d7d;
            --muted2: #5a5a5a;
            --accent: #a6ff00;
            --accent-dim: rgba(166, 255, 0, 0.18);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg);
            color: var(--text);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            overflow: hidden;
            height: 100vh;
        }
        #map {
            width: 100%;
            height: 100vh;
            background: var(--bg);
        }

        /* Leaflet uses a light gray background by default; override so "empty" areas aren't white. */
        .leaflet-container { background: var(--bg) !important; }

        /* Panels */
        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 0;
            padding: 16px;
            z-index: 1000;
            backdrop-filter: blur(6px);
        }

        /* Header / brand */
        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            line-height: 1;
        }
        .brand .logo {
            width: 16px;
            height: 16px;
            object-fit: contain;
            display: block;
        }
        .brand .name {
            color: var(--text);
            font-weight: 700;
            letter-spacing: 0.2px;
        }
        .brand .sub {
            color: var(--muted);
            font-weight: 500;
        }

        /* Stats overlay */
        #stats {
            position: fixed;
            top: 16px;
            left: 16px;
            min-width: 260px;
            max-width: 360px;
        }

        .toggle-btn {
            display: none;
            margin-top: 10px;
            width: 100%;
            padding: 8px 10px;
            background: transparent;
            border: 1px solid var(--border-strong);
            color: var(--accent);
            font: inherit;
            font-size: 11px;
            letter-spacing: 0.6px;
            text-transform: lowercase;
            cursor: pointer;
        }
        .toggle-btn:hover { background: rgba(255,255,255,0.04); }

        /* Responsive: avoid overlay collisions on mobile */
        @media (max-width: 760px) {
            #stats {
                top: 12px;
                left: 12px;
                right: 12px;
                min-width: 0;
                max-width: none;
            }

            #node-list {
                top: auto;
                right: 12px;
                left: 12px;
                bottom: 12px;
                width: auto;
                max-height: 42vh;
            }

            #node-list.collapsed {
                max-height: 44px;
                overflow: hidden;
            }
            #node-list.collapsed #nodes-container { display: none; }
            #node-list h2 { margin-bottom: 0; }

            .toggle-btn { display: block; }
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .stat-label { color: var(--muted); text-transform: uppercase; letter-spacing: 0.6px; font-size: 10px; }
        .stat-value { color: var(--text); font-weight: 600; font-size: 14px; }

        #status {
            margin-top: 10px;
            font-size: 11px;
            color: var(--muted2);
        }
        #status.crawling { color: #ffb300; }
        #status.ready { color: var(--accent); }

        /* Node list panel */
        #node-list {
            position: fixed;
            top: 16px;
            right: 16px;
            max-height: calc(100vh - 32px);
            width: 340px;
            overflow-y: auto;
        }
        #node-list h2 {
            font-size: 12px;
            color: var(--accent);
            font-weight: 700;
            letter-spacing: 0.8px;
            text-transform: lowercase;
            margin-bottom: 10px;
        }
        .node-entry {
            padding: 8px 10px;
            margin: 0 -10px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            font-size: 12px;
            cursor: pointer;
        }
        .node-entry:hover { background: rgba(255, 255, 255, 0.04); }
        .node-entry.no-geo { cursor: default; opacity: 0.65; }
        .node-entry.no-geo:hover { background: transparent; }

        .node-ip { color: var(--accent); font-family: inherit; }
        .node-location { color: var(--muted); margin-left: 10px; }

        /* Slider control */
        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .control-row label {
            font-size: 11px;
            color: var(--muted);
            text-transform: lowercase;
            letter-spacing: 0.6px;
        }
        input[type=range] {
            -webkit-appearance: none;
            width: 60%;
            background: transparent;
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.12);
            border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -4px;
        }
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.12);
            border-radius: 2px;
        }
        input[type=range]::-moz-range-thumb {
            height: 12px;
            width: 12px;
            border: none;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
        }

        /* Leaflet popup override */
        .leaflet-popup-content-wrapper {
            background: rgba(0, 0, 0, 0.9) !important;
            color: var(--text) !important;
            border: 1px solid var(--border-strong);
            border-radius: 0;
        }
        .leaflet-popup-tip { background: rgba(0, 0, 0, 0.9) !important; }
        .popup-content { font-size: 12px; line-height: 1.6; }
        .popup-content .label { color: var(--muted); }
        .popup-content .value { color: var(--accent); font-family: inherit; }

        /* Scrollbar */
        #node-list::-webkit-scrollbar { width: 6px; }
        #node-list::-webkit-scrollbar-track { background: transparent; }
        #node-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); }
        #node-list::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.18); }

        @media (max-width: 760px) {
            /* Hide zoom controls on mobile to prevent overlap with bottom panel */
            .leaflet-control-zoom { display: none; }

            /* Larger slider thumb for easier touch interaction */
            input[type=range]::-webkit-slider-thumb {
                height: 20px; width: 20px; margin-top: -8px;
            }
            input[type=range]::-moz-range-thumb {
                height: 20px; width: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div id="stats" class="panel">
        <div class="brand">
            <img class="logo" src="/blocknet.png" alt="blocknet" />
            <span class="name">blocknet</span>
            <span class="sub">nodes</span>

        <div class="stat-row">
            <span class="stat-label">Nodes</span>
            <span class="stat-value" id="node-count">—</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Countries</span>
            <span class="stat-value" id="country-count">—</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Last Crawl</span>
            <span class="stat-value" id="last-crawl">—</span>
        </div>
        <div id="status">Connecting...</div>
        <button id="toggle-node-list" class="toggle-btn" type="button">hide list</button>
    </div>

    <div id="node-list" class="panel">
        <h2># node list</h2>
        <div class="control-row">
            <label for="conn-opacity">connections</label>
            <input type="range" id="conn-opacity" min="0" max="100" value="100">
        </div>
        <div id="nodes-container"></div>
    </div>

    <script>
        // Initialize map with dark tiles.
        // Disable horizontal world wrap so we don't get an "infinite" side-scrolling map.
        const worldBounds = L.latLngBounds(L.latLng(-85, -180), L.latLng(85, 180));

        const map = L.map('map', {
            center: [20, 0],
            zoom: 2,
            minZoom: 2,
            maxZoom: 13,
            zoomControl: false,
            maxBounds: worldBounds,
            maxBoundsViscosity: 1.0,
            worldCopyJump: true,
        });

        // With noWrap enabled, zoom 2 can leave empty gutters on very wide viewports because the
        // single world copy may be narrower than the screen (world size = 256 * 2^zoom).
        // Bump the initial zoom up just enough to fill the viewport, but don't force-zoom down later.
        function zoomToFillWorld() {
            const size = map.getSize();
            const tile = 256;
            const zW = Math.ceil(Math.log(size.x / tile) / Math.LN2);
            const zH = Math.ceil(Math.log(size.y / tile) / Math.LN2);
            return Math.max(zW, zH);
        }

        function bumpZoomIfNeeded() {
            // Cap to something reasonable so we don't suddenly zoom very far in on extremely wide displays.
            const cap = Math.min(map.getMaxZoom(), 6);
            const ideal = Math.max(map.getMinZoom(), Math.min(cap, zoomToFillWorld()));
            if (map.getZoom() < ideal) map.setZoom(ideal);
        }

        L.control.zoom({ position: 'bottomleft' }).addTo(map);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19,
            noWrap: true,
            bounds: worldBounds,
        }).addTo(map);

        // Ensure the map has a computed size before we decide on an initial zoom.
        map.whenReady(() => {
            requestAnimationFrame(() => bumpZoomIfNeeded());
        });

        // Re-check on resize (debounced).
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(bumpZoomIfNeeded, 120);
        });

        // Custom glowing marker icon.
        function createNodeIcon() {
            return L.divIcon({
                className: '',
                html: `<div style="
                    width: 10px; height: 10px;
                    background: var(--accent);
                    border: 1px solid rgba(166, 255, 0, 0.35);
                    border-radius: 50%;
                    box-shadow: 0 0 8px 3px rgba(166, 255, 0, 0.28);
                "></div>`,
                iconSize: [10, 10],
                iconAnchor: [5, 5],
            });
        }

        // Connection arcs (rendered on canvas for better performance than SVG when many paths are present).
        const connectionRenderer = L.canvas({ padding: 0.5 });
        let connections = L.layerGroup().addTo(map);

        let markers = L.layerGroup().addTo(map);
        let nodeData = [];
        let connOpacity = 1.0;

        async function fetchNodes() {
            try {
                const [nodesResp, statsResp] = await Promise.all([
                    fetch('/api/nodes'),
                    fetch('/api/stats'),
                ]);
                const nodes = await nodesResp.json();
                const stats = await statsResp.json();

                nodeData = nodes || [];
                updateMap(nodeData);
                updateStats(stats);
                updateNodeList(nodeData);

                const statusEl = document.getElementById('status');
                statusEl.textContent = `Updated ${new Date().toLocaleTimeString()}`;
                statusEl.className = 'ready';
            } catch (err) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = `Error: ${err.message}`;
                statusEl.className = 'crawling';
            }
        }

        function hasGeo(node) {
            if (!Number.isFinite(node?.lat) || !Number.isFinite(node?.lng)) return false;
            // Treat (0,0) as "unknown" unless the lookup gave us a real location.
            if (node.lat === 0 && node.lng === 0 && !node.country && !node.city) return false;
            return true;
        }

        function updateMap(nodes) {
            updateConnections(nodes);

            markers.clearLayers();
            const icon = createNodeIcon();

            for (const node of nodes) {
                if (!hasGeo(node)) continue;

                const marker = L.marker([node.lat, node.lng], { icon })
                    .bindPopup(`
                        <div class="popup-content">
                            <div><span class="label">IP:</span> <span class="value">${node.ip}</span></div>
                            <div><span class="label">Peer:</span> <span class="value">${node.peer_id.substring(0, 16)}…</span></div>
                            <div><span class="label">Location:</span> <span class="value">${node.city || '?'}, ${node.country || '?'}</span></div>
                            <div><span class="label">ISP:</span> <span class="value">${node.isp || '?'}</span></div>
                            <div><span class="label">Last Seen:</span> <span class="value">${formatTime(node.last_seen)}</span></div>
                        </div>
                    `);
                markers.addLayer(marker);
            }
        }

        function updateConnections(nodes) {
            connections.clearLayers();

            const geoNodes = (nodes || []).filter(hasGeo);
            const n = geoNodes.length;
            if (n < 2) return;

            // Drawing a full mesh becomes expensive quickly (O(n^2) edges). Keep a hard cap so the UI stays responsive.
            const maxEdges = 2500;

            const allPairs = (n * (n - 1)) / 2;
            const edges = [];

            if (allPairs <= maxEdges) {
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        edges.push([geoNodes[i], geoNodes[j]]);
                    }
                }
            } else {
                // Deterministically connect each node to a handful of other nodes to stay under maxEdges.
                // Use a key set so we don't end up skipping lots of edges for higher i values.
                const k = Math.min(n - 1, Math.max(1, Math.floor(maxEdges / n)));
                const edgeKeys = new Set();

                for (let i = 0; i < n; i++) {
                    const seed = geoNodes[i].peer_id || geoNodes[i].ip || String(i);
                    const picks = pickOtherNodeIndexes(seed, n, k, i);

                    for (const j of picks) {
                        const aIdx = Math.min(i, j);
                        const bIdx = Math.max(i, j);
                        if (aIdx === bIdx) continue;

                        const key = `${aIdx}:${bIdx}`;
                        if (edgeKeys.has(key)) continue;
                        edgeKeys.add(key);

                        edges.push([geoNodes[aIdx], geoNodes[bIdx]]);
                        if (edges.length >= maxEdges) break;
                    }

                    if (edges.length >= maxEdges) break;
                }
            }

            // Styling: draw a soft "glow" stroke first, then the main dashed arc on top.
            // (Canvas renderer makes this fast enough even with a couple thousand edges.)
            const arcColor = '#a6ff00';
            const glowOpts = {
                renderer: connectionRenderer,
                color: arcColor,
                weight: 5,
                opacity: 0.08 * connOpacity, // Glow opacity (background)
                lineCap: 'round',
                interactive: false,
            };
            const arcOpts = {
                renderer: connectionRenderer,
                color: arcColor,
                weight: 2,
                opacity: 0.42 * connOpacity, // Main line opacity (foreground)
                dashArray: '4 6',
                lineCap: 'round',
                interactive: false,
            };

            for (const [a, b] of edges) {
                const pts = greatCirclePoints([a.lat, a.lng], [b.lat, b.lng], 24);
                const segments = splitAtAntimeridian(pts);

                for (const seg of segments) {
                    if (seg.length < 2) continue;
                    L.polyline(seg, glowOpts).addTo(connections);
                    L.polyline(seg, arcOpts).addTo(connections);
                }
            }
        }

        // Leaflet draws straight segments between points. When a line crosses the ±180° meridian,
        // longitudes jump from +179 to -179 (or vice versa), producing a long "across the world" segment.
        // Split the line at the antimeridian (adding intersection points) to prevent wrap artifacts.
        function splitAtAntimeridian(points) {
            if (!points || points.length < 2) return [points || []];

            const segments = [];
            let seg = [points[0]];

            for (let i = 1; i < points.length; i++) {
                const [prevLat, prevLng] = points[i - 1];
                const [currLat, currLng] = points[i];

                const aLng = wrapLng(prevLng);
                const bLng = wrapLng(currLng);

                if (Math.abs(aLng - bLng) <= 180) {
                    seg.push([currLat, bLng]);
                    continue;
                }

                // Crossing detected.
                const border = aLng > 0 ? 180 : -180;
                let bAdj = bLng;
                if (border === 180 && bAdj < 0) bAdj += 360;
                if (border === -180 && bAdj > 0) bAdj -= 360;

                const denom = (bAdj - aLng);
                const t = denom === 0 ? 0.5 : (border - aLng) / denom;
                const latAtBorder = prevLat + t * (currLat - prevLat);

                // Finish current segment at the border.
                seg.push([latAtBorder, border]);
                segments.push(seg);

                // Start a new segment on the opposite side of the world.
                seg = [[latAtBorder, -border], [currLat, bLng]];
            }

            if (seg.length) segments.push(seg);
            return segments;
        }

        function wrapLng(lng) {
            // Wrap into [-180, 180)
            return ((((lng + 180) % 360) + 360) % 360) - 180;
        }

        function pickOtherNodeIndexes(seedStr, n, k, excludeIdx) {
            if (n <= 1) return [];
            const kk = Math.min(n - 1, Math.max(0, k));

            const rng = xorshift32(hashString(seedStr) || 1);
            const picked = new Set();

            // k is expected to be small relative to n.
            while (picked.size < kk) {
                const idx = Math.floor(rng() * n);
                if (idx === excludeIdx) continue;
                picked.add(idx);
            }

            return [...picked];
        }

        // 32-bit FNV-1a.
        function hashString(str) {
            let h = 0x811c9dc5;
            for (let i = 0; i < str.length; i++) {
                h ^= str.charCodeAt(i);
                h = Math.imul(h, 0x01000193);
            }
            return h >>> 0;
        }

        function xorshift32(seed) {
            let x = seed >>> 0;
            return function () {
                x ^= x << 13;
                x ^= x >>> 17;
                x ^= x << 5;
                return (x >>> 0) / 4294967296;
            };
        }

        // Returns points along the great-circle path between two coordinates.
        // Adapted from standard spherical linear interpolation.
        function greatCirclePoints(a, b, segments) {
            const [lat1, lon1] = a;
            const [lat2, lon2] = b;

            const φ1 = toRad(lat1);
            const λ1 = toRad(lon1);
            const φ2 = toRad(lat2);
            const λ2 = toRad(lon2);

            const sinΔφ = Math.sin((φ2 - φ1) / 2);
            const sinΔλ = Math.sin((λ2 - λ1) / 2);

            const aa = sinΔφ * sinΔφ + Math.cos(φ1) * Math.cos(φ2) * sinΔλ * sinΔλ;
            const δ = 2 * Math.asin(Math.min(1, Math.sqrt(aa)));

            // Same point.
            if (!Number.isFinite(δ) || δ === 0) return [[lat1, lon1], [lat2, lon2]];

            const sinδ = Math.sin(δ);
            const pts = [];

            for (let i = 0; i <= segments; i++) {
                const f = i / segments;
                const A = Math.sin((1 - f) * δ) / sinδ;
                const B = Math.sin(f * δ) / sinδ;

                const x = A * Math.cos(φ1) * Math.cos(λ1) + B * Math.cos(φ2) * Math.cos(λ2);
                const y = A * Math.cos(φ1) * Math.sin(λ1) + B * Math.cos(φ2) * Math.sin(λ2);
                const z = A * Math.sin(φ1) + B * Math.sin(φ2);

                const φi = Math.atan2(z, Math.sqrt(x * x + y * y));
                const λi = Math.atan2(y, x);
                pts.push([toDeg(φi), toDeg(λi)]);
            }

            return pts;
        }

        function toRad(deg) { return (deg * Math.PI) / 180; }
        function toDeg(rad) { return (rad * 180) / Math.PI; }

        function updateStats(stats) {
            document.getElementById('node-count').textContent = stats.total_nodes || 0;
            document.getElementById('country-count').textContent = stats.countries || 0;

            const lastCrawl = stats.last_crawl;
            if (lastCrawl && lastCrawl > 0) {
                document.getElementById('last-crawl').textContent = formatTime(lastCrawl);
            } else {
                document.getElementById('last-crawl').textContent = 'Crawling…';
            }
        }

        function updateNodeList(nodes) {
            const container = document.getElementById('nodes-container');
            // Sort by country then IP.
            const sorted = [...nodes].sort((a, b) => {
                const ca = (a.country || '').localeCompare(b.country || '');
                if (ca !== 0) return ca;
                return (a.ip || '').localeCompare(b.ip || '');
            });

            container.innerHTML = sorted.map(n => {
                const geo = hasGeo(n);
                const cls = geo ? 'node-entry' : 'node-entry no-geo';
                const click = geo ? `onclick="flyTo(${n.lat}, ${n.lng})"` : '';
                return `
                    <div class="${cls}" ${click}>
                        <span class="node-ip">${n.ip}</span>
                        <span class="node-location">${n.city ? n.city + ', ' : ''}${n.country || 'Unknown'}</span>
                    </div>
                `;
            }).join('');
        }

        function flyTo(lat, lng) {
            if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
            map.flyTo([lat, lng], 6, { duration: 1 });
        }

        function formatTime(unix) {
            if (!unix || unix <= 0) return '—';
            const d = new Date(unix * 1000);
            const now = new Date();
            const diffMs = now - d;
            const diffMin = Math.floor(diffMs / 60000);
            if (diffMin < 1) return 'just now';
            if (diffMin < 60) return `${diffMin}m ago`;
            const diffHr = Math.floor(diffMin / 60);
            if (diffHr < 24) return `${diffHr}h ago`;
            return d.toLocaleDateString();
        }

        // Mobile UX: collapse node list by default so the overlays don't collide.
        const nodeListEl = document.getElementById('node-list');
        const toggleNodeListBtn = document.getElementById('toggle-node-list');

        function isMobile() {
            return window.matchMedia && window.matchMedia('(max-width: 760px)').matches;
        }

        function setNodeListCollapsed(collapsed) {
            if (!nodeListEl) return;
            nodeListEl.classList.toggle('collapsed', collapsed);
            if (toggleNodeListBtn) {
                toggleNodeListBtn.textContent = collapsed ? 'show list' : 'hide list';
            }
        }

        if (toggleNodeListBtn) {
            toggleNodeListBtn.addEventListener('click', () => {
                const collapsed = nodeListEl?.classList.contains('collapsed');
                setNodeListCollapsed(!collapsed);
            });
        }

        // Also allow tapping the node-list header to expand/collapse on mobile.
        const nodeListHeader = document.querySelector('#node-list h2');
        if (nodeListHeader) {
            nodeListHeader.addEventListener('click', () => {
                if (!isMobile()) return;
                const collapsed = nodeListEl?.classList.contains('collapsed');
                setNodeListCollapsed(!collapsed);
            });
        }

        let wasMobile = isMobile();
        setNodeListCollapsed(wasMobile);
        window.addEventListener('resize', () => {
            const mobileNow = isMobile();
            if (mobileNow === wasMobile) return;
            wasMobile = mobileNow;
            setNodeListCollapsed(wasMobile);
        });

        // Connection opacity slider.
        document.getElementById('conn-opacity').addEventListener('input', (e) => {
            connOpacity = parseInt(e.target.value, 10) / 100;
            connections.eachLayer(layer => {
                // Glow is weight 5, Arc is weight 2.
                const base = (layer.options.weight === 5) ? 0.08 : 0.42;
                layer.setStyle({ opacity: base * connOpacity });
            });
        });

        // Initial fetch + auto-refresh every 60s.
        fetchNodes();
        setInterval(fetchNodes, 60000);
    </script>
</body>
</html>
